package cz.vutbr.feec.nn;

import java.util.Comparator;
import java.util.LinkedList;
import java.util.TreeSet;

public class NetworkGenerator {
	private Layer[] layer;
	private String inputShape;
	private String outputShape;
	private Boolean mnistBlockFlag; // making sure theres only one mnist block in network (false default)

	/**
	 * Vytvori dopredny acyklicky graf (sit), kde na prvni casti jsou konvoluce a
	 * konkatenace a na nasledujicich jsou Dense vrstvy a konkatenace. Parametry
	 * jsou generovany zcela nahodne.
	 * 
	 * @param capacity
	 * @param inputShape
	 * @param outputShape
	 */
	public NetworkGenerator(int capacity, String inputShape, String outputShape) {
		mnistBlockFlag = false; // no mnist_block in network
		this.layer = new Layer[capacity];
		layer[0] = new InputLayer(0, this); // input layer creation
		layer[1] = new Conv1DLayer(1, this, 20); // first hidden layer
		for (int i = 2; i < layer.length; i++) {
			double rnd = Math.random();
			if (rnd < 0.70) { // 70 % probability
				if (i < layer.length / 2) { // first convolutions
					layer[i] = new Conv1DLayer(i, this, 20);
				} else if (rnd <0.50) {
					layer[i] = new MnistBlock(i, this);
				} else {
					layer[i] = new Conv1DLayer(i, this, 20); // TODO insert different block
				}
			} else if (rnd >= 0.70 && rnd < 85) {
				layer[i] = new BatchNormalization(i, this);
			} else {
				layer[i] = new BatchNormalization(i, this); // TODO different layer
			}
		}
		this.inputShape = "shape=(" + inputShape + ")";
		this.outputShape = outputShape;
	}

	// generovani python kodu
	public String build() {
		StringBuilder str = new StringBuilder();
		str.append("# Generated by network generator\n");
		// str.append("# Importing libraries\n");
		str.append("from keras.models import Model\n");
		str.append("from keras.layers import Input\n");
		str.append("from keras.layers import Dense\n");
		str.append("from keras.layers import Conv1D\n");
		str.append("from keras.layers import Flatten\n");
		str.append("from keras.layers import Dropout\n");
		str.append("from keras.layers import BatchNormalization\n");
		str.append("from keras.layers import Conv2D\n");
		str.append("from keras.layers import MaxPooling2d\n");
		str.append("from keras.layers.merge import concatenate\n");
		str.append("\n");
		// str.append("# Creating model");

		Layer last = layer[layer.length - 1];
		LinkedList<Layer> layers = new LinkedList<>();
		layers.addLast(last);

		TreeSet<Layer> set = new TreeSet<>(new Comparator<Layer>() {
			public int compare(Layer o1, Layer o2) {
				return o1.getLayerId().compareTo(o2.getLayerId());
			};
		});
		// remove duplicates
		while (!layers.isEmpty()) {
			Layer l = layers.pop();
			set.add(l);
			// add all following to queue
			for (Layer layer : l.getPreviousLayers()) {
				layers.addLast(layer);
			}
		}
		// print
		for (Layer layer : set) {
			str.append(layer.build());
			str.append("\n");
		}

		// to correct num of layers as output
		str.append("layer_last = Dense(" + outputShape + ", activation='sigmoid')(" + set.last().getLayerId() + ")\n");
		str.append("model = Model(inputs=" + set.first().getLayerId() + ", outputs=layer_last)");
		return str.toString();
	}

	public Layer getLayer(int id) {
		return layer[id];
	}

	public String getInputShape() {
		return inputShape;
	}

	public String getOutputShape() {
		return outputShape;
	}

	public void setMnistBlockFlag(Boolean mnistBlockFlag) {
		this.mnistBlockFlag = mnistBlockFlag;
	}

	public Boolean getMnistBlockFlag() {
		return mnistBlockFlag;
	}

}
